database engine: acts as db factory and manages the db connections, owns the connection pool and hence provides connection whenever needed. It is thread safe, should be created once.

database session: a unit of work manager for efficient db operations. It wraps a db connection borrowed from engine's connection pool. Manages transaction, ensures consistency and is created per request hence is short lived.

Lifecycle: -
Application starts
   ↓
Engine created once
   ↓
Request comes in
   ↓
Session created (borrows connection from engine pool)
   ↓
ORM operations (query / insert / update)
   ↓
Commit or rollback
   ↓
Session closed (connection returned to pool)

why should we create the DB session using a dependency instead of directly inside each route?
“We use a dependency to manage DB sessions so that session creation, transaction scope, and cleanup are centralized and guaranteed.
This avoids connection leaks, removes duplication, ensures one session per request, and makes the system testable and maintainable.
FastAPI’s dependency system makes this explicit, but the pattern exists across all backend frameworks.”

filter() → for expressions

filter_by() → for simple equality via kwargs

When and when not to use try except blocks: -
We avoid blanket try/except blocks in FastAPI endpoints because the framework already handles exception propagation and cleanup. We only catch exceptions at boundaries where we can translate low-level errors into meaningful domain or HTTP errors, or when we need to ensure transactional integrity.

Relationships give navigation, not automatic joins.
Data is fetched lazily unless you explicitly eager-load it.
Serialization is controlled by schemas, not ORM relationships.

Square brackets are used for generics because they operate at the type level, allowing FastAPI and Pydantic to specialize schemas for validation and documentation.

## alembic notes:-
- alembic.ini: main config file for alembic
- env.py: runs on every alembic command, sets up the context for migrations
- versions/: folder where migration scripts are stored
- make sure to set target_metadata in env.py to your models' metadata for auto generation to work.
- also import your models in env.py so that alembic is aware of them.
- for dynamic db url injection, config.set_main_option("sqlalchemy.url", your_db_url) can be used in env.py
Common alembic commands:
- alembic revision --autogenerate -m "message": create a new migration script with autogenerated changes
- alembic upgrade head: apply all migrations to the latest version
- alembic downgrade -1: revert the last migration
- alembic current: show the current revision of the database
- alembic history: show the list of all migrations
- alembic heads: show the current head revisions
- alembic branches: show the current branches in the migration history
- alembic stamp head: mark the database as up-to-date without applying migrations (useful for initial setup)